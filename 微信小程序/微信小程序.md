# 微信小程序

# [基础](https://mp.weixin.qq.com/debug/wxadoc/dev/)

## 代码构成

 * JSON配置

 	* app.json：当前小程序全局配置

 		pages：当前小程序所有页面路径

 		window：默认页面的窗口表现

 		tabBar：设置tab的表现

 		networkTimeout：网络超时事件

 		debug： 是否开启debug模式

 	* project.config.json：开发者工具配置，如界面颜色，代码上传压缩等

 	* page.json：为单个页面指定不同于app.json的特殊属性

 * WXML模板

	* 自定义组件，包装原原生标签，如text，view等

	* 自定义指令，表现与数据分离，如wx:if等

 * WXSS样式

	* 新增尺寸单位，使用rpx避免换算

	* app.wxss设置全局样式，page.wxss设置当前页面样式

 * js交互

## 小程序能力

* 小程序启动

	1. app.json的pages数组第一项为小程序首页
	
	2. 加载首页代码进行渲染
	
	3. 触发app.js中的onLaunch回调函数

* 程序与页面

	1. 根据page.json配置生成页面，其中定义顶部颜色与文字

	2. 加载WXML与WXSS

	3. 加载page.js，渲染页面
	
	4. 触发onload回调

* 组件

	组件传值、事件绑定

* API

## 发布前准备

开发者权限管理、小程序预览、代码上传、版本号设置等

## 小程序上线

提交审核、发布、运营数据查看

# [框架](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/MINA.html)

* MVVM框架，视图层与逻辑层分离

* 页面管理

* 基础组件

* API

## 文件结构

根目录： app.js，app.json，app.wxss

	app.wxss：小程序公共样式表，全局样式设置

单一页面：page.wxml，page.js，page.wxss，page.json

**描述同一页面的所有文件必须具有相同的路径与文件名**

## 配置

app.json

* pages：array，每一项为string，路径+文件名，指定小程序的页面组成
	
	**数组中第一项问初始页，小程序页面增删均需在此修改**

* window：object，设置小程序状态栏、导航条、标题与窗口背景色
	
	![小程序窗口示意图](https://mp.weixin.qq.com/debug/wxadoc/dev/image/config.jpg?t=2018119)

* tabBar：array，每一项为单个tab设置参数，设置tab表现
	
	如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面

* networkTimeout：设置各种网络请求超时时间

	* request：wx.request超时时间，单位ms，默认60000
	* connectSocket：同上
	* uploadFile：同上
	* downloadFile：同上

* debug

page.json：其中只会设置app.json中的window项与disableScroll，会对window进行覆盖
	
## 逻辑层

* 增加App与Page方法，进行小程序与页面的注册。
* getApp与getCurrentPages获取App实例与当前页面栈
* 模块化开发，每个页面独立作用域
* **浏览器中一些对象无法使用，如document与window**
* 所有代码打包成一份JavaScript

### App

#### App()：用于注册小程序。接收object参数，其中指定小程序生命周期函数

生命周期 | 意义 | 触发时机
onLaunch | 监听小程序初始化 | 小程序初始化完成，触发一次
onShow | 监听小程序显示 | 小程序启动或从后台进入前台显示，进行触发
onHide | 监听小程序隐藏 | 小程序进入后台，进行触发
onError | 错误监听函数 | 脚本错误与API调用失败，进行触发并带上错误参数
其他 | any | 此处定义的函数或数据，可以使用this全局访问

**onLaunch与onShow参数**

#### getApp()

返回App对象

注意事项：
* App()必须在app.js中注册，只能注册一个
* 在App()内可以使用this直接获取App对象
* 不能在onLaunch中获取page对象，此时尚未生成
* 不能私自调用生命周期函数

### 场景值

### Page

#### Page()：用于注册页面。接收一个object参数，其中页面初始化数据、生命周期函数、事件处理函数等

object参数：
	
* data： 页面初始数据，负责页面第一次渲染，其中数据必须是字符串、数字、布尔、对象与数组格式
* 生命周期函数
	
	* onLoad：页面加载时触发，每个只调用一次
		
		参数为其他页面打开当前页面所调用的query参数

	* onShow：每次页面显示时都会调用
	* onReady：页面初次渲染完成，每个页面只调用一次，**代表当前页面以准备妥当，可以与视图层进行交互**
	* onHide：页面隐藏，在navigateTo或者底部tab切换时调用
	* onUnload：页面卸载，在redirectTo或navigateBack时调用
	
	![page实例生命周期](https://mp.weixin.qq.com/debug/wxadoc/dev/image/mina-lifecycle.png?t=2018119)

* 页面事件处理函数

	* onPullDownRefresh：下拉刷新

		* 需要在app.json中的window选项或page.json中开启enablePullDownRefresh

		* 处理完数据刷新后，可以使用wx.stopPullDownRefresh可以停止当前页面的下拉刷新

	* onReahBottom：上拉触底

		* 可以在app.json的window选项中或页面配置中设置触发距离onReachBottomDistance
		
		* 在触发距离内滑动期间，本事件只会触发一次

	* onPageScroll：页面滚动
		* 参数为object，包含scrollTop也现在垂直方向已滚动的距离，单位px

	* onShareAPPMessage：用户转发

		* **只有定义了此事件处理函数，右上角菜单才会出现转发按钮**
		* 用户点击转发按钮时调用
		* 此事件需要return一个object，其中定义转发内容title与path，分别为转发标题与转发路径

* 其他函数，在页面的函数中可以通过this访问

**object内容在页面加载时会进行一次深拷贝，需注意其大小对深拷贝影响**


#### 页面其他数据

* Page.prototype.route：获取当前页面路径

* Page.prototype.setData()：
	* 同步改变对应的this.data值，也可用于新增数据
	* 异步将数据同步至视图层
	* 参数：
		* data：object，必填
		* callback：**在本次setData对视图层渲染完毕后调用**
	* 直接使用this.data修改数据不会同步至视图层
	* 设置undefined值将会被忽略，且会导致其他问题


### 页面路由

#### 页面栈

路由切换时，页面栈表现如下

路由方式 | 页面栈表现
---- | ----
初始化 | 新页面入栈
打开新页面 | 新页面入栈
页面重定向 | 当前页面出栈，新页面入栈
页面返回 | 页面不断出栈，直到目标返回页，新页面入栈
tab切换 | 页面全部出栈，只留下新的tab页面
重加载 | 页面全部出栈，只留下新的页面


#### getCurrentPages()

返回值为数组，数组顺序为栈的顺序，第一个元素为首页，最后一个元素为当前页面

#### 路由方式

不同路由切换方式对页面生命周期函数触发不同

具体参见[页面路由](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/route.html)


### 模块化

#### 文件作用域

* 在 JavaScript 文件中声明的变量和函数只在该文件中有效
* 通过全局函数 getApp() 可以获取全局的应用实例，如果需要全局的数据可以在 App() 中设置
	
		// app.js
		App({
		  globalData: 1
		})

#### 模块化

* 通过module.exports向外暴露模块接口，暂不支持npm
* 通过require引入模块，**require暂不支持绝对路径**

## 视图层

### WXML

#### 数据绑定

WXML中所有的数据均来自对应page中的data，data也可在调用组件时指定

	<template is="objectCombine" data="{{foo, bar}}"></template>

数据的绑定使用双大括号包裹变量

#### 列表渲染wx:for

当前项变量名默认为item，当前项下标默认为index

	<view wx:for="{{array}}">
	  {{index}}: {{item.message}}
	</view>

使用`wx:for-item`修改当前项变量名，使用`wx:for-index`修改当前项下表名

	<view wx:for="{{array}}" wx:for-index="idx" wx:for-item="itemName">
	  {{idx}}: {{itemName.message}}
	</view>

**wx:key为列表中每一项提供唯一的标识符**，当视图层重新渲染时，保证这些项不会被重新创建，以保持其自身状态，如input中输入内容与选择器的选中状态，并且提高渲染效率。

key的提供方式：

* 字符串，依赖于item的某个property，需要取值独一无二
* 关键字`*this`，代表for循环中的item自身，需要item本身是一个唯一的字符串或数字

注意：

* 当针对字符串使用wx:for，会将字符串拆解为字符数组
* 花括号与引号之间存在空格时，循环内容会最终被解析为字符串

		<view wx:for="{{[1,2,3]}} ">
		  {{item}}
		</view>
		//等价于
		<view wx:for="{{[1,2,3] + ' '}}" >
		  {{item}}
		</view>

#### 条件渲染wx:if

**惰性渲染，渲染与销毁**

	<view wx:if="{{length > 5}}"> 1 </view>
	<view wx:elif="{{length > 2}}"> 2 </view>
	<view wx:else> 3 </view>

wx:if与hidden关系同v-if与v-show，频繁切换使用hidden更好

* wx:if切换消耗高
* hidden初始渲染消耗高

#### 模板

* 模板定义，使用name属性

* 模板使用，使用is属性，is属性值可以动态绑定

* 模板作用域，只是用data传入数据与其wxs模块

#### 事件

事件捕获与冒泡：

[冒泡事件列表](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/event.html)

事件绑定：

* key使用bind或catch开头，bind:eventName、catch:eventName，旧版本下没有冒号
* value为字符串，内容为函数名


**bind事件绑定不会阻止冒泡事件冒泡，catch会阻止事件冒泡**

**capture-bind在捕获阶段触发事件，capture-catch将会终端捕获阶段和取消冒泡阶段**

事件对象：
	
默认情况下事件触发时，处理函数会收到一个事件对象

event： 

* BaseEvent 基础事件对象属性列表
* CustomEvent 自定义事件对象属性列表（继承 BaseEvent）
* TouchEvent 触摸事件对象属性列表（继承 BaseEvent）
* type 事件类型
* timeStamp 页面打开到触发事件经过的毫秒数
* target 触发事件的源组件
* currentTarget 事件绑定的当前组件
* dataset 读写数据
	
	在组件使用中可以使用data-self-data设置自定义数据。

	**自定义数据的名称不能有大写字符，大写字符自动转为小写。多个单词使用短横线连接，框架会自动将其转化为驼峰**

	使用`event.currentTarget.dataset.selfData`可以获取与设置自定义数据。此处使用驼峰写法

* touches 数组，每个元素为touch对象，canvas触摸事件中为touches是CanvasTouch数组
* changedTouches，数据格式同touches
* detail，自定义事件携带的数据，如表单提交事件中用户的输入等

#### 引用

* import，import目标文件后可以在被文件中调用引入的组件

		<import src="b.wxml"/>

		<template is="B"/>

* include，可以将目标文件除了 <template/> <wxs/> 外的整个代码引入
		
	**相当于将引入的组件直接拷贝到include的位置使用**

### WXS：WeiXin Script 

wxs代码可以编写在wxml文件的wxs标签内，或者一个.wxs的文件中

**note**

* wxs与JavaScript是不同的语言，二者语法不一致
* wxs与JavaScript运行环境隔离。wxs不能调用JavaScript的函数，也不能调用小程序API
* wxs不能作为组件事件回调

wxs与JavaScript结合使用示例：

	<wxs module="m1">
	var add = function(num) {
	  var result = num + 1;
	  return result;
	}
	
	module.exports.add = add;
	</wxs>
	
	<!-- num在JavaScript的data中定义 -->
	<view> {{m1.add(num)}} </view>

#### 模块

每个wxs文件和wxs标签都是一个单独的模块，作用域独立，通过module.exports向外暴露接口

wxs文件可以被其他的wxs文件或者wxs标签引用

	// 标签引用
	<wxs src="./../tools.wxs" module="tools" />
	// wxs文件引用
	var tools = require("./tools.wxs");

**wxs文件的require注意事项：**

* 只能引用wxs文件模块，且必须使用相对路径
* wxs模块为单例，第一次被引用时初始化为单例对象，此后在多个地方、多个页面、多次引用均使用的同一个wxs模块对象
* 如果一个wxs模块定义后从未被引用，则其不会被解析与运行

**wxs标签**

* src，引用wxs文件的相对路径，仅当本标签为单闭合标签或标签的内容为空时有效
	
	相对路径，单例模式，不引用不会解析执行

* module，当前wxs标签的模块名。
	
	重复的模块名会按照先后顺序覆盖，其命名遵循变量命名规则

**<template> 标签中，只能使用定义该 <template> 的 WXML 文件中定义的 <wxs> 模块**

#### 变量

* wxs中的变量均为值的引用
* 没有声明的变量直接使用，定义为全局变量
* 声明未赋值的变量，默认值undefined
* var与JavaScript中相同，存在变量提升

其他参见ES5

## WXSS

与CSS区别在于尺寸单位与样式导入

尺寸单位：

* rpx：规定屏幕宽度为750rpx，针对屏幕真实宽度进行自适应

样式导入：

* 外联样式表：@import 相对路径;

		@import "common.wxss";

* 内联样式：使用style绑定动态样式，避免在其中使用静态样式

		<view style="color:{{color}};" />

支持选择器类型：id，class，tag，before，after，element element


**app.wxss中样式为全局样式，作用于所有页面**

**page.wxss中样式为局部样式，作用于当前页面，覆盖app.wxss**

## 自定义组件

低耦合度，组件复用

* 创建自定义组件

	自定义组件问价的组成方式类似于页面，但需要在**page.json中进行自定义组件声明，将component字段设为true**

		{
		  "component": true
		}

	* WXML与WXSS与普通页面大体相同
		
		在组件wxss中不应使用ID选择器、属性选择器和标签名选择器

	* js文件
		* 使用Component()注册组件
		* properties对象声明外部参数
		* data对象声明初始参数
		* methods对象声明自定义方法

代码示例：

	Component({
	  properties: {
	    // 这里定义了innerText属性，属性值可以在组件使用时指定
	    innerText: {
	      type: String,
	      value: 'default value',
	    }
	  },
	  data: {
	    // 这里是一些组件内部数据
	    someData: {}
	  },
	  methods: {
	    // 这里是一个自定义方法
	    customMethod: function(){}
	  }
	})

* 使用自定义组件

	1. page.json中进行引用声明
		
			{
			  "usingComponents": {
			    "component-tag-name": "path/to/the/custom/component"
			  }
			}

	2. wxml中直接使用自定义组件
		
			<view>
			  <!-- 以下是对一个自定义组件的引用 -->
			  <component-tag-name inner-text="Some text"></component-tag-name>
			</view>

		**注意属性注入时的大小写问题**

		**因为WXML节点标签名只能是小写字母、中划线和下划线的组合，所以自定义组件的标签名也只能包含这些字符**


### 组件模板与样式

#### slot分发

组件模版的写法与页面模板相同。组件模版与组件数据结合后生成的节点树，将被插入到组件的引用位置上。

* 多个slot需要现在component函数中进行声明

		Component({
		  options: {
		    multipleSlots: true // 在组件定义时的选项中启用多slot支持
		  },
		  properties: { /* ... */ },
		  methods: { /* ... */ }
		})

* 不同slot之间通过name进行区分

		<!-- 组件模板 -->
		<view class="wrapper">
		  <slot name="before"></slot>
		  <view>这里是组件的内部细节</view>
		  <slot name="after"></slot>
		</view>

* slot使用

		<!-- 引用组件的页面模版 -->
		<view>
		  <component-tag-name>
		    <!-- 这部分内容将被放置在组件 <slot name="before"> 的位置上 -->
		    <view slot="before">这里是插入到组件slot name="before"中的内容</view>
		    <!-- 这部分内容将被放置在组件 <slot name="after"> 的位置上 -->
		    <view slot="after">这里是插入到组件slot name="after"中的内容</view>
		  </component-tag-name>
		</view>

#### 组件样式

* 组件和引用组件的页面不能使用id选择器（#a）、属性选择器（[a]）和标签名选择器，**请改用class选择器**
* 继承样式，如 font 、 color ，会从组件外继承到组件内
* 除继承样式外， **app.wxss 中的样式、组件所在页面的的样式对自定义组件无效**
* **组件可以指定它所在节点的默认样式，使用 :host 选择器**

		/* 组件 custom-component.wxss */
		:host {
		  color: yellow;
		}
		<!-- 页面的 WXML -->
		<custom-component>这段文本是黄色的</custom-component>